<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=HarmonyOS+Sans+Light:300,300italic,400,400italic,700,700italic%7CHarmonyOS+Sans+Blod:300,300italic,400,400italic,700,700italic%7CHarmonyOS+Sans+Regular:300,300italic,400,400italic,700,700italic%7CFira+Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/black/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"betterspace.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":false,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="这里是CSC3100 Assignment3的笔记，希望对你有帮助！ 有关树型动态规划&amp;红黑树">
<meta property="og:type" content="article">
<meta property="og:title" content="CSC3100 Assignment3[已完成]">
<meta property="og:url" content="http://betterspace.top/2023/12/19/CSC3100%20Assignment3/index.html">
<meta property="og:site_name" content="BetterSpace">
<meta property="og:description" content="这里是CSC3100 Assignment3的笔记，希望对你有帮助！ 有关树型动态规划&amp;红黑树">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://betterspace.top/pics/TreeBP.jpg">
<meta property="article:published_time" content="2023-12-19T08:05:00.000Z">
<meta property="article:modified_time" content="2023-12-19T08:05:37.277Z">
<meta property="article:author" content="越来越好的鸡翅">
<meta property="article:tag" content="计算机">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://betterspace.top/pics/TreeBP.jpg">


<link rel="canonical" href="http://betterspace.top/2023/12/19/CSC3100%20Assignment3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://betterspace.top/2023/12/19/CSC3100%20Assignment3/","path":"2023/12/19/CSC3100 Assignment3/","title":"CSC3100 Assignment3[已完成]"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CSC3100 Assignment3[已完成] | BetterSpace</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">BetterSpace</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">A space for better world.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Node-Distance"><span class="nav-number">1.</span> <span class="nav-text">1 Node Distance</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Description"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Input"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 Input</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">1.3.</span> <span class="nav-text">思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">可能的算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF1-%E5%BE%AA%E7%8E%AF%E6%AF%8F%E4%B8%80%E5%AF%B9%E9%BB%91%E8%89%B2%E8%8A%82%E7%82%B9%EF%BC%8C%E5%AF%BB%E6%89%BE%E5%85%B6LCA%EF%BC%8C%E7%84%B6%E5%90%8E%E8%AE%A1%E7%AE%97%E8%B7%9D%E7%A6%BB%EF%BC%8C%E6%9C%80%E5%90%8E%E7%9B%B8%E5%8A%A0%E3%80%82"><span class="nav-number">1.3.2.</span> <span class="nav-text">思路1 循环每一对黑色节点，寻找其LCA，然后计算距离，最后相加。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%9A%84%E6%80%9D%E8%B7%AF1-%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E6%80%9D%E6%83%B3%E3%80%82"><span class="nav-number">1.3.3.</span> <span class="nav-text">优化的思路1 我们可以考虑使用动态规划的思想。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF2-%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E6%A0%91%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E6%80%9D%E6%83%B3%E3%80%82"><span class="nav-number">1.3.4.</span> <span class="nav-text">思路2 我们可以考虑使用树型动态规划的思想。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tarjan%E7%AE%97%E6%B3%95-%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8Tarjan%E7%AE%97%E6%B3%95%E3%80%82%EF%BC%88%E8%BF%98%E6%B2%A1%E5%B0%9D%E8%AF%95%EF%BC%89"><span class="nav-number">1.3.5.</span> <span class="nav-text">Tarjan算法 我们可以考虑使用Tarjan算法。（还没尝试）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Price-Sequence"><span class="nav-number">2.</span> <span class="nav-text">2 Price Sequence</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1Description"><span class="nav-number">2.1.</span> <span class="nav-text">2.1Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Input"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 Input</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="nav-number">2.3.</span> <span class="nav-text">思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CLOSEST-ADJ-PRICE"><span class="nav-number">2.3.1.</span> <span class="nav-text">CLOSEST ADJ PRICE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CLOSEST-PRICE"><span class="nav-number">2.3.2.</span> <span class="nav-text">CLOSEST PRICE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">2.3.3.</span> <span class="nav-text">更进一步的优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NodeDistance-java"><span class="nav-number">3.</span> <span class="nav-text">NodeDistance.java</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PriceSequence-java"><span class="nav-number">4.</span> <span class="nav-text">PriceSequence.java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Download-Links-%E4%BD%9C%E4%B8%9A%E5%8E%9F%E6%96%87%E6%A1%A3%E4%B8%8B%E8%BD%BD"><span class="nav-number">4.1.</span> <span class="nav-text">Download Links 作业原文档下载</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="越来越好的鸡翅"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">越来越好的鸡翅</p>
  <div class="site-description" itemprop="description">Welcome to BetterSpace!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/BetterAndBetterII" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;BetterAndBetterII" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://betterspace.top/2023/12/19/CSC3100%20Assignment3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="越来越好的鸡翅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BetterSpace">
      <meta itemprop="description" content="Welcome to BetterSpace!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="CSC3100 Assignment3[已完成] | BetterSpace">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CSC3100 Assignment3[已完成]
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-12-19 16:05:00 / 修改时间：16:05:37" itemprop="dateCreated datePublished" datetime="2023-12-19T16:05:00+08:00">2023-12-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><!-- 摘要 -->
<ul>
<li>这里是CSC3100 Assignment3的笔记，希望对你有帮助！</li>
<li>有关树型动态规划&amp;红黑树<span id="more"></span></li>
</ul>
<h1 id="1-Node-Distance"><a href="#1-Node-Distance" class="headerlink" title="1 Node Distance"></a>1 Node Distance</h1><h2 id="1-1-Description"><a href="#1-1-Description" class="headerlink" title="1.1 Description"></a>1.1 Description</h2><p> You are given a tree with $n$ nodes, where each edge in the tree has a corresponding weight denoting the<br> length of each edge. The nodes in the tree are colored either black or white. Your task is to calculate the sum of distances between every pair of black nodes in the tree. Let $B&#x3D;{b_1,b_2,…}$ a set of black nodes, then the answer is formulated as:<br>$$Ans&#x3D;\sum_{i&#x3D;1}^{|B|-1}\sum_{j&#x3D;i+1}^{|B|}\operatorname{dist}(b_i,b_j)$$<br>where $|B|$ denotes the number of the black nodes in the tree, and $\det(b_i,b_j)$ is the length of the simple path from the $i$-th to $j$-th black node.<br> Write a program to calculate the sum of distances on the tree between every pair of black nodes $Ans$<br> in the given tree.</p>
<h2 id="1-2-Input"><a href="#1-2-Input" class="headerlink" title="1.2 Input"></a>1.2 Input</h2><p> The first line contains an integer $n$, representing the number of nodes in the tree.<br> The second line contains $n$ space-separated integers ${c_1,c_2,\ldots,c_i,\ldots,c_n}$ where $c_i$ is either 0 or l.<br> $c_i&#x3D; 1$ indicates that the $i$-th node is black, and $c_i&#x3D;0$ indicates that the $i$-th node is white.<br> The following $n-1\operatorname*{lines},{l_1,l_2,\ldots,l_p,\ldots,l_{n-1}}$, denoting the structure of the tree follow, each line<br> $l_p$ contains 2 integers $q_p$ and $w_p$, denoting an edge of length $w_p$ between the $\color{red}{p+1}$-th node and the $q_{p^-}th$ node.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="可能的算法"><a href="#可能的算法" class="headerlink" title="可能的算法"></a>可能的算法</h3><p>因为我们要计算的是每一对黑色节点之间的距离，所以我们可以考虑使用动态规划的思想，即将问题分解为子问题，然后逐步求解。</p>
<p>我们先想一下，如果我们要计算一对黑色节点之间的距离，我们可以怎么做呢？</p>
<p>学过树的话，大家肯定都知道LCA-最近公共祖先，我们可以通过LCA来计算两个节点之间的距离。</p>
<pre><code>比如我要计算节点a和节点b之间的距离，那么我们可以先找到他们的LCA，然后计算a到LCA的距离和b到LCA的距离，然后相加即可。
</code></pre>
<p>所以我们有了一个算法：</p>
<h3 id="思路1-循环每一对黑色节点，寻找其LCA，然后计算距离，最后相加。"><a href="#思路1-循环每一对黑色节点，寻找其LCA，然后计算距离，最后相加。" class="headerlink" title="思路1 循环每一对黑色节点，寻找其LCA，然后计算距离，最后相加。"></a>思路1 循环每一对黑色节点，寻找其LCA，然后计算距离，最后相加。</h3><p>这个思路的时间复杂度是$O(n^3)$，因为我们要循环每一对黑色节点，然后寻找LCA，这个过程的时间复杂度是$O(n)$（这里还不可以用大跳优化到$O(logn)$），所以总的时间复杂度是$O(n^3)$。</p>
<p>很明显，这个算法太慢了，我们需要优化。</p>
<h3 id="优化的思路1-我们可以考虑使用动态规划的思想。"><a href="#优化的思路1-我们可以考虑使用动态规划的思想。" class="headerlink" title="优化的思路1 我们可以考虑使用动态规划的思想。"></a>优化的思路1 我们可以考虑使用动态规划的思想。</h3><p>因为如果我们要找到一个黑色节点到LCA的距离，只能一步一步地向上去找，直到抵达LCA。</p>
<p>深入思考一下，我们可以运用树差分的思想：<br>    计算两个节点之间的距离 &#x3D; 两个节点到根节点的距离和 - LCA到根节点的距离的两倍</p>
<p>这个思路的优越性在于，任意一个节点到根节点的距离只需要计算一次！如果后续我们需要这些数据，我们直接取用即可！</p>
<p>更进一步，我们还可以再用一个动态规划：<br>    计算某个节点到根节点的距离，我们只需要用这个节点的父节点到根节点的距离加上这个节点到父节点的距离即可！</p>
<p><strong>大跳优化</strong> 我们可以考虑使用大跳优化：<br>    即我们在计算之前，我们先遍历一次树。假设某个节点的深度为$d$，我们储存这个节点的第$2^i$个祖先，这个祖先的深度为$d-2^i$，这样我们就可以在$O(logn)$的时间内找到任意一个节点的第2^i个祖先。</p>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>计算每个节点到根节点的距离：这一步可以通过一次深度优先搜索（DFS）完成。在这个DFS过程中，每个节点被访问一次，并且在访问其子节点时，我们更新子节点到根节点的距离。这一步的时间复杂度是$O(N)$，其中 N 是树中节点的数量。</p>
</li>
<li><p>寻找最低公共祖先（LCA）：这通常通过预处理父节点数组来实现，使得每次查询的复杂度可以降至$O(1)$（例如使用二进制提升方法）。预处理的复杂度是$ O(NlogN)$。</p>
</li>
<li><p>计算两个节点之间的距离：使用树差分的思想，可以在$O(1)$时间内完成，因为我们已经预处理了到根节点的距离。所以，我们可以先计算每个节点到根节点的距离，然后再寻找LCA，最后累加黑色节点间的距离即可，这样的时间复杂度是$O(n^2)$。</p>
</li>
<li><p>累加黑色节点间的距离：如果黑色节点的数量是$K$，那么在最坏的情况下，需要进行$O(K^2)$次LCA查询和距离计算，因为你可能需要考虑所有黑色节点对之间的距离。所以，这一步的时间复杂度是$O(K^2)$。</p>
</li>
<li><p>预处理：$O(Nlong(N))$（计算到根节点的距离和预处理LCA查询）</p>
</li>
<li><p>查询和计算距离：$O(K^2)$（对于所有黑色节点对）</p>
</li>
<li><p><strong>总的时间复杂度</strong>：$O(Nlog(N)+K^2)$</p>
</li>
</ul>
<p>但是这个算法还是太慢了，我们还需要优化！</p>
<h3 id="思路2-我们可以考虑使用树型动态规划的思想。"><a href="#思路2-我们可以考虑使用树型动态规划的思想。" class="headerlink" title="思路2 我们可以考虑使用树型动态规划的思想。"></a>思路2 我们可以考虑使用树型动态规划的思想。</h3><p>我们希望只遍历一次树，就可以算出所有的距离。而不是像思路1那样，针对每一对黑色节点，都要遍历一次树。</p>
<p>这里用到了Bell同学的思路，这是一张示意图：</p>
<p><img src="/pics/TreeBP.jpg" alt="树型动态规划" title="树型动态规划"></p>
<p>我们可以看到，这里用到了一个更加复杂的状态转移方程：<br>$$f(u) &#x3D; f(fa(u)) + siz(A) - siz(B)$$<br>其中：</p>
<ul>
<li>$f(u)$表示以节点$u$为根的子树中，所有黑色节点到节点$u$的距离之和。</li>
<li>$fa(u)$表示节点$u$的父节点。</li>
<li>$siz(A)$表示集合A中，所有黑色节点的数量。</li>
<li>$siz(B)$表示集合B中，所有黑色节点的数量，也就是节点$u$的子树中，黑色节点的数量。</li>
</ul>
<p>状态是如何转移的呢？</p>
<p>注意到，<br>$$Ans &#x3D; \frac{1}{2}\sum_{u\in BlackNodes} f(u), $$<br>就是我们要求的答案。</p>
<!-- u属于黑色节点集合 -->

<p>我们可以看到，$f(u)$是由$f(fa(u))$转移而来的，而$f(fa(u))$是由$f(fa(fa(u)))$转移而来的，而$f(fa(fa(u)))$是由$f(fa(fa(fa(u))))$转移而来的，以此类推。</p>
<p>那么，我们可以得到一个结论：<br>    如果我们知道了$f(fa(u))$，那么我们就可以计算出$f(u)$。（假设siz已知）</p>
<p>这提示我们可以从根节点开始，逐步向下计算。</p>
<p>对于根节点<br>$$f(root) &#x3D; \sum_{u\in BlackNodes}distToRoot(u)$$</p>
<p>因此，我们现在已经清楚了我们要什么：</p>
<ul>
<li>$distToRoot(u)$：节点$u$到根节点的距离</li>
<li>$siz(A)$：集合$A$（节点$u$的子树）中，所有黑色节点的数量</li>
</ul>
<p><strong>复杂度分析</strong></p>
<ul>
<li>计算到根节点的距离$distToRoot()$：使用记忆化搜索，这部分的复杂度为$O(n)$。</li>
<li>计算子树大小和黑色节点的距离$siz()$：这通过一次 DFS 实现，复杂度为$O(n)$。</li>
<li>计算状态转移方程$f()$：节点数量决定，复杂度为$O(n)$。</li>
<li>计算所有黑色节点的距离和：这部分的复杂度是$O(b^2)$，因为它基于每个黑色节点到根的距离和子树中黑色节点的数量。</li>
</ul>
<p>综上所述，这个算法的时间复杂度是：<br>$$O(n + b^2)$$<br>当$b$接近$n$时，这个算法的时间复杂度是$O(n^2)$。</p>
<p>这是非常好的！<strong>（代码见文末）</strong> <a href="#NodeDistance.java">NodeDistance.java</a></p>
<h3 id="Tarjan算法-我们可以考虑使用Tarjan算法。（还没尝试）"><a href="#Tarjan算法-我们可以考虑使用Tarjan算法。（还没尝试）" class="headerlink" title="Tarjan算法 我们可以考虑使用Tarjan算法。（还没尝试）"></a>Tarjan算法 我们可以考虑使用Tarjan算法。（还没尝试）</h3><p>对于多次的查询，我们可能会想到并查集，<strong>Tarjan算法</strong>，在遍历树的同时，我们就可以找到LCA，还有一次性处理多个查询请求的好处（离线算法）。</p>
<p>但是，在这一个题目中，如果我们在遍历树的同时，计算黑色节点之间的距离和，还是相当繁琐的。这里给出一个思路。</p>
<p><strong>步骤1：构建树结构和初始化</strong></p>
<ol>
<li>构建树：使用输入的边信息构建一棵树，可以使用邻接表表示。</li>
<li>存储节点信息：对于每个节点，存储其颜色 (黑或自) 以及从根节点到该节点的路径长度。</li>
</ol>
<p><strong>步骤2：深度优先搜索(DFS)和 Tarjan 算法</strong></p>
<ol>
<li>DFS 遍历：从根节点开始，对树进行深度优先搜索。在这个过程中，记录每个节点的父节点和深度。</li>
<li>黑色节点哈稀表：初始化一个哈希表来存储遍历过程中的黑色节点到当前节点 (LCA) 的距离。</li>
</ol>
<p><strong>步骤3：结合LCA 查找和距离计算</strong></p>
<ol>
<li>在DFS中查找LCA：在DFS过程中，当遍历到一个黑色节点时，利用Tarian算法找到它和之前遍历的黑色节点的 LCA。</li>
<li>更新哈希表：将这个黑色节点到 LCA 的距离加入到 LCA 的哈希表中。</li>
<li>计算距离：对于哈希表中的每一个黑色节点，计算它与新遍历的黑色节点之间的距离，并累加。</li>
</ol>
<p><strong>步骤4：合并并查集</strong></p>
<ol>
<li>合并集合：在 DFS 后退时 (即完成一个节点的子树遍历后), 合并当前节点与其子节点的并查集。</li>
<li>合并哈希表：同时合并哈希表，将子树中的黑色节点到当前节点的距离更新。</li>
</ol>
<p>这个算法的时间复杂度是$O(n\alpha(n) + B^2)$，其中$\alpha(n)$是阿克曼函数的反函数，B是黑色节点的数量。</p>
<p>在这里，$\alpha()$反阿克曼函数非常小，对于所有实际的输入大小，它几乎可以认为是一个很小的常数，通常不会超过 4。所以，尽管$\alpha(n)$ 在理论上慢于$log(n)$，但在实际的应用中，它的增长如此之慢，以至于可以认为它比$log(n)$小很多。</p>
<p>但是，由于黑色节点之间的距离仍是通过很多次累加计算得到的，仍然避免不了$O(B^2)$的复杂度。</p>
<p>因此，这个算法的时间复杂度是$O(n + B^2)$，这是一个还不错的结果，但整体思路不如思路2直接了当。有兴趣的读者可以尝试一下哦！</p>
<h1 id="2-Price-Sequence"><a href="#2-Price-Sequence" class="headerlink" title="2 Price Sequence"></a>2 Price Sequence</h1><h2 id="2-1Description"><a href="#2-1Description" class="headerlink" title="2.1Description"></a>2.1Description</h2><p> Mario bought $n$ math books and he recorded their prices. The prices are all integers, and the price<br> sequence is $a&#x3D;{a_0,a_2,…a_i,…,a_{n-1}}$ of length $n\left(n\leq100000\right)$ .Please help him to manage this price sequence. There are three types of operations:</p>
<ul>
<li>BUY x: buy a new book with price $x$, thus $x$ is added at the end of $a.$ </li>
<li>CLOSEST ADJ PRICE: output the minimum absolute difference between adjacent prices.</li>
<li>CLOSEST-PRICE: output the absolute difference between the two closest prices in the entire sequence.</li>
</ul>
<p>A total of $m$ operations are performed $(1\leq m\leq100000)$. Each operation is one of the three mentioned types. You need to write a program to perform given operations. For operations “CLOSEST_ADJ PRICE” and “CLOSEST PRICE” you need to output the corresponding answers.</p>
<h2 id="2-2-Input"><a href="#2-2-Input" class="headerlink" title="2.2 Input"></a>2.2 Input</h2><p> The first line contains two integers $n$ and $m$, representing the length of the original sequence and the<br> number of operations.<br> The second line consists of $n$ integers, representing the initial sequence $a.$<br> Following that are $m$ lines, each containing one operation: either BUY x, CLOSEST_ADJ PRICE, or<br> CLOSEST PRICE (without extra spaces or empty lines).</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h3 id="CLOSEST-ADJ-PRICE"><a href="#CLOSEST-ADJ-PRICE" class="headerlink" title="CLOSEST ADJ PRICE"></a>CLOSEST ADJ PRICE</h3><p>这个操作很简单，我们只需要维护一个最小的相邻差值即可。随着我们不断地添加新的价格，我们只需要比较新的价格和上一个价格的差值，然后更新最小的相邻差值即可。</p>
<h3 id="CLOSEST-PRICE"><a href="#CLOSEST-PRICE" class="headerlink" title="CLOSEST PRICE"></a>CLOSEST PRICE</h3><p>这个操作稍微复杂一点，我们需要维护一个最小的价格差值。深入思考一下就会发现，只要将价格排序，然后比较相邻的两个价格差值，就可以得到最小的价格差值。</p>
<p>但是，我们不可能每次都对价格进行排序，这样的时间复杂度是$O(nlogn)$。</p>
<p>既然又需要插入，又需要排序。我们很容易就能想到红黑树：一种自平衡的二叉查找树，它的时间复杂度是$O(logn)$。</p>
<p>插入之后，我们只需要计算插入位置的前后之间的差值，再与原来相邻价格的差值的最小值相比较，这样即可得到CLOSEST PRICE。</p>
<h3 id="更进一步的优化"><a href="#更进一步的优化" class="headerlink" title="更进一步的优化"></a>更进一步的优化</h3><p>由于作业要求中，有两个样例不需要我们维护CLOEST PRICE，而其中<strong>BUY</strong>的数据量可能又相当大。所以我们需要优化CLOSEST PRICE的维护。</p>
<table>
<thead>
<tr>
<th>Test Case No.</th>
<th>Constraints</th>
</tr>
</thead>
<tbody><tr>
<td>1-4</td>
<td>n ≤ $10^3$, m ≤ $10^3$</td>
</tr>
<tr>
<td>5-6</td>
<td>There is no <strong>CLOSEST PRICE</strong> operation</td>
</tr>
<tr>
<td>7-9</td>
<td>$a_i$ and $x$ are uniformly distributed at random within the range [0, $10^{12}$]</td>
</tr>
<tr>
<td>10</td>
<td>No additional constraints</td>
</tr>
</tbody></table>
<p>我们可以考虑CLOEST PRICE用到时再计算。将BUY的操作储存起来，CLOSEST ADJ PRICE依然随着BUY而更新，但请求CLOEST PRICE时，再将所有BUY记录一次性插入红黑树中，然后进行计算。这样，我们CLOEST PRICE的计算就不会影响CLOSEST ADJ PRICE的效率了！</p>
<p><strong>（代码见文末）</strong> <a href="#PriceSequence.java">PriceSequence.java</a></p>
<h1 id="NodeDistance-java"><a href="#NodeDistance-java" class="headerlink" title="NodeDistance.java"></a>NodeDistance.java</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class name changed to match file name NodeDistance.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodeDistance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define class-level variables</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] parent, length, blackAndWhite;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] f, distDP, blackNum;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, List&lt;Integer&gt;&gt; children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> lineNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NumberFormatException, IOException &#123;</span><br><span class="line">        <span class="comment">// Initialize arrays with an offset for 1-indexed access</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        lineNum = Integer.parseInt(input.readLine());</span><br><span class="line">        blackAndWhite = <span class="keyword">new</span> <span class="title class_">int</span>[lineNum + <span class="number">1</span>];</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[lineNum + <span class="number">1</span>];</span><br><span class="line">        length = <span class="keyword">new</span> <span class="title class_">int</span>[lineNum + <span class="number">1</span>];</span><br><span class="line">        f = <span class="keyword">new</span> <span class="title class_">long</span>[lineNum + <span class="number">1</span>];</span><br><span class="line">        distDP = <span class="keyword">new</span> <span class="title class_">long</span>[lineNum + <span class="number">1</span>];</span><br><span class="line">        blackNum = <span class="keyword">new</span> <span class="title class_">long</span>[lineNum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the color information for nodes</span></span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(input.readLine());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= lineNum; i++) &#123;</span><br><span class="line">            blackAndWhite[i] = Integer.parseInt(st.nextToken());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read and construct the tree structure</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; lineNum; i++) &#123;</span><br><span class="line">            st = <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(input.readLine());</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(st.nextToken());</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(st.nextToken());</span><br><span class="line">            <span class="keyword">if</span> (a &gt; i + <span class="number">1</span>) &#123;</span><br><span class="line">                parent[a] = i + <span class="number">1</span>;</span><br><span class="line">                addChild(i + <span class="number">1</span>, a);</span><br><span class="line">                length[a] = b;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[i + <span class="number">1</span>] = a;</span><br><span class="line">                addChild(a, i + <span class="number">1</span>);</span><br><span class="line">                length[i + <span class="number">1</span>] = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        input.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Determine the structure of the tree</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isCircle</span> <span class="operator">=</span> <span class="literal">true</span>, isLine = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= lineNum; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[i] != <span class="number">1</span>) &#123;</span><br><span class="line">                isCircle = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if the tree structure is a line</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= lineNum; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; childList = children.get(parent[i]);</span><br><span class="line">            <span class="keyword">if</span> (childList != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">if</span> (childList.size() &gt; <span class="number">1</span> || (parent[i] != i - <span class="number">1</span>)) &#123;</span><br><span class="line">                    isLine = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect black nodes for further processing</span></span><br><span class="line">        List&lt;Integer&gt; blackNodesList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= lineNum; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (blackAndWhite[i] == <span class="number">1</span>)</span><br><span class="line">                blackNodesList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] blackNodes = blackNodesList.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optimize calculation based on the tree structure</span></span><br><span class="line">        <span class="keyword">if</span> (isLine) &#123;</span><br><span class="line">            calculateLineDistance(blackNodes);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCircle) &#123;</span><br><span class="line">            calculateCircleDistance(blackNodes);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pre-compute the distance from each node to the root</span></span><br><span class="line">        Arrays.fill(f, -<span class="number">1</span>);</span><br><span class="line">        Arrays.fill(blackNum, -<span class="number">1</span>);</span><br><span class="line">        Arrays.fill(distDP, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">totalDistanceToRoot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> blackNode : blackNodes) &#123;</span><br><span class="line">            totalDistanceToRoot += distToRoot(blackNode);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">1</span>] = totalDistanceToRoot;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute the size of the subtree and distances for black nodes</span></span><br><span class="line">        sizeDfs(<span class="number">1</span>);  <span class="comment">//gx</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sumDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> blackNode : blackNodes) &#123;</span><br><span class="line">            sumDistance += dfs(blackNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Output the total distance</span></span><br><span class="line">        System.out.println(sumDistance / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method to calculate distances in a linear tree</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">calculateLineDistance</span><span class="params">(<span class="type">int</span>[] blackNodes)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] distanceToRoot = <span class="keyword">new</span> <span class="title class_">int</span>[lineNum + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= lineNum; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[i] != <span class="number">0</span>) &#123; <span class="comment">// If parent exists</span></span><br><span class="line">                distanceToRoot[i] = distanceToRoot[parent[i]] + length[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">totalDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; blackNodes.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; blackNodes.length; j++) &#123;</span><br><span class="line">                totalDistance += Math.abs(distanceToRoot[blackNodes[i]] - distanceToRoot[blackNodes[j]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(totalDistance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method to calculate distances in a circular tree</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">calculateCircleDistance</span><span class="params">(<span class="type">int</span>[] blackNodes)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">totalDistance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; blackNodes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; blackNodes.length; j++) &#123;</span><br><span class="line">                totalDistance += length[blackNodes[i]] + length[blackNodes[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(totalDistance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Helper method to compute distance to root for a given node</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">distToRoot</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (distDP[node] == -<span class="number">1</span>) &#123;</span><br><span class="line">            distDP[node] = (<span class="type">long</span>) length[node] + distToRoot(parent[node]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distDP[node];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Helper method to add a child to a node in the tree</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(<span class="type">int</span> par, <span class="type">int</span> child)</span> &#123;</span><br><span class="line">        children.computeIfAbsent(par, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DFS method to calculate distances from a node to all black nodes</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="number">1</span>) <span class="keyword">return</span> f[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (f[node] == -<span class="number">1</span>) &#123;</span><br><span class="line">            f[node] = dfs(parent[node]) + length[node] * (blackNum[<span class="number">1</span>] - <span class="number">2</span> * blackNum[node]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[node];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DFS method to calculate the size of subtrees</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sizeDfs</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (blackNum[node] != -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        blackNum[node] = blackAndWhite[node] == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; childList = children.get(node);</span><br><span class="line">        <span class="keyword">if</span> (childList != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> child : childList) &#123;</span><br><span class="line">                sizeDfs(child);</span><br><span class="line">                blackNum[node] += blackNum[child];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="PriceSequence-java"><a href="#PriceSequence-java" class="headerlink" title="PriceSequence.java"></a>PriceSequence.java</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriceManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TreeSet&lt;Long&gt; prices; <span class="comment">// TreeSet to maintain sorted unique prices</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> minAdjacentDiff, lastPrice = -<span class="number">1</span>; <span class="comment">// Track the minimum adjacent difference and the last price added</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pIndex</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// Pointer to process pending BUY operations</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; pendingBuys; <span class="comment">// Store pending BUY operations</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">minPriceDiff</span> <span class="operator">=</span> Long.MAX_VALUE; <span class="comment">// Track the minimum difference between any two prices</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PriceManager</span><span class="params">()</span> &#123;</span><br><span class="line">        prices = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        pendingBuys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        minAdjacentDiff = Long.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds all new prices and updates the minimum price difference incrementally</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAllPrice</span><span class="params">(List&lt;Long&gt; priceList)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Long price : priceList) &#123;</span><br><span class="line">            <span class="comment">// Skip processing if the minimum difference is already 0</span></span><br><span class="line">            <span class="keyword">if</span>(minPriceDiff == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Find the higher and lower prices for comparison</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">higher</span> <span class="operator">=</span> prices.higher(price);</span><br><span class="line">            <span class="type">Long</span> <span class="variable">lower</span> <span class="operator">=</span> prices.lower(price);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the price already exists, the minimum difference is 0</span></span><br><span class="line">            <span class="keyword">if</span>(prices.contains(price)) &#123;</span><br><span class="line">                minPriceDiff = <span class="number">0L</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Update the minimum difference based on the higher and lower neighbors</span></span><br><span class="line">                <span class="keyword">if</span> (higher != <span class="literal">null</span>) &#123;</span><br><span class="line">                    minPriceDiff = Math.min(minPriceDiff, Math.abs(higher - price));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (lower != <span class="literal">null</span>) &#123;</span><br><span class="line">                    minPriceDiff = Math.min(minPriceDiff, Math.abs(price - lower));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            prices.add(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Records a pending BUY operation to be processed later</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recordBuy</span><span class="params">(<span class="type">long</span> price)</span> &#123;</span><br><span class="line">        pendingBuys.add(price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process all pending BUY operations and update the minimum adjacent difference</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processPendingBuys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (pIndex &lt; pendingBuys.size()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">price</span> <span class="operator">=</span> pendingBuys.get(pIndex++);</span><br><span class="line">            <span class="keyword">if</span> (lastPrice != -<span class="number">1</span>) &#123;</span><br><span class="line">                minAdjacentDiff = Math.min(minAdjacentDiff, Math.abs(lastPrice - price));</span><br><span class="line">            &#125;</span><br><span class="line">            lastPrice = price;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the closest adjacent price</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">closestAdjacentPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        processPendingBuys();</span><br><span class="line">        <span class="keyword">return</span> minAdjacentDiff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the closest price difference between any two prices</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">closestPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.addAllPrice(pendingBuys);</span><br><span class="line">        pendingBuys.clear(); <span class="comment">// Clear the pending BUY operations after processing</span></span><br><span class="line">        pIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> minPriceDiff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(input.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(st.nextToken()); <span class="comment">// Initial number of prices</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> Integer.parseInt(st.nextToken()); <span class="comment">// Number of operations</span></span><br><span class="line"></span><br><span class="line">        <span class="type">PriceManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriceManager</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Record initial BUY operations</span></span><br><span class="line">        st = <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(input.readLine());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            manager.recordBuy(Long.parseLong(st.nextToken()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process operations</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            st = <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(input.readLine());</span><br><span class="line">            <span class="type">String</span> <span class="variable">operation</span> <span class="operator">=</span> st.nextToken();</span><br><span class="line">            <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;BUY&quot;</span>:</span><br><span class="line">                    <span class="type">long</span> <span class="variable">price</span> <span class="operator">=</span> Long.parseLong(st.nextToken());</span><br><span class="line">                    manager.recordBuy(price);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;CLOSEST_ADJ_PRICE&quot;</span>:</span><br><span class="line">                    System.out.println(manager.closestAdjacentPrice());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;CLOSEST_PRICE&quot;</span>:</span><br><span class="line">                    System.out.println(manager.closestPrice());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        input.close(); <span class="comment">// Close the input stream</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<!-- 下载链接 -->
<h2 id="Download-Links-作业原文档下载"><a href="#Download-Links-作业原文档下载" class="headerlink" title="Download Links 作业原文档下载"></a>Download Links 作业原文档下载</h2><ul>
<li><a href="/pdf/xid-6673999_AS_3.pdf" title="作业原文档下载">CSC3100 Assignment3</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag"># 计算机</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Python/" rel="tag"># Python</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/12/17/%E4%BB%8EMarkdown%E5%88%B0Latex/" rel="prev" title="-[一键制作CheatingPaper!]:从Markdown到Latex[未完成]">
                  <i class="fa fa-angle-left"></i> -[一键制作CheatingPaper!]:从Markdown到Latex[未完成]
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/12/21/GPTSider%EF%BC%8C%E4%BD%A0%E7%9A%84%E6%A1%8C%E9%9D%A2AI%E5%8A%A9%E6%89%8B/" rel="next" title="GPTSider，你的桌面AI助手">
                  GPTSider，你的桌面AI助手 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  
  <div class="comments giscus-container">
  </div>
  
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">越来越好的鸡翅</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/BetterAndBetterII" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  
  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.12/pdfobject.min.js","integrity":"sha256-g2xji1rlE3KsGVClvuxTbcR0Kn2+wtQADSff2Tbb4zA="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>




  <script src="/js/third-party/pace.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"BetterAndBetterII/BetterAndBetterII.github.io","repo_id":"R_kgDOK5hhiQ","category":"Ideas","category_id":"DIC_kwDOK5hhic4Cbv_t","mapping":"pathname","reactions_enabled":1,"emit_metadata":1,"theme":"light","lang":"zh-CN","crossorigin":"anonymous","input_position":"bottom","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
